"""
Main Python script for submission
Implements the required functions for CW1.
"""
from typing import Callable
import numpy as np
import matplotlib.pyplot as plt

def show_answer(func, word_limit=40):
    """
    Do not remove or modify this function
    """
    
    text = func.__doc__ or ""
    words = text.split()

    limited = words[:word_limit]
    truncated = len(words) > word_limit

    result = " ".join(limited)
    if truncated:
        result += " ...[truncated]"

    return result


def fixedpoint_with_stopping(g, p0, Nmax, TOL, p=None, C=None, k=None):
    """
    
    Using the fixed-point iteration method, this function solves the problem p = g(p)

    Args:
        :param g: The function which will be iterated over
        :param p0: The initial guess to the solution of p = g(p)
        :param Nmax: The maximum number of iterations over g
        :param TOL: The tolerance for the stopping criteria defined as |p_m - p_(m-1)| <= TOL
        :param p: The exact solution to p = g(p) if known, otherwise it is None
        :param C: One of the positive constants used to define the stopping criteria |p - p_n| <= CK^n 
        :param K: One of the positive constants used to define the stopping criteria |p - p_n| <= CK^n

    Returns:
        :numpy.ndarray called p_array with shape (m,) containing the iterates p_n generated by the fixed point iteration before
        reaching Nmax iterations or after the iterations hits Nmax

    Outputs:
        :(if p is known) a graph corresponding to the plot of the absolute error |p - p_n| using a logarithmic scale on the y-axis
        :(if C and k are provided) a plot of the error bound CK^n on the same graph as the above 
    
    """


    p_array = np.zeros(Nmax)
    
    #Write your code for fixed point iteration according to the instructions:

    p0 = g(p0)
    p_array[0] = p0

    n = 1
    while n < Nmax:
        p_n = g(p0)
        p_array[n] = p_n
        if(np.abs(p_n - p_array[n-1]) <= TOL):
            break
        p0 = p_n
        n += 1
    p_array = p_array[:n+1]

    # Write your code to generate plots according to the instructions:

    if p is not None:
        fig, ax = plt.subplots()
        errors = np.abs(p - np.array(p_array))
        n = np.arange(len(errors))

        ax.set_yscale("log")
        ax.set_xlabel("Iteration")
        ax.set_ylabel("|p - p_n|")

        ax.plot(n, errors, label="|p - p_n|")

        if C is not None and k is not None:
            bound = C * (k ** n)
            ax.plot(n, bound, "--", label="Ck^n")
        ax.legend()
    else:
        fig = ax = None

    if fig is not None and ax is not None:
        return p_array, fig, ax
    else:
        return p_array

def q1B_answer():
    """
    Answer to Question 1b(i): Linear
    
    Answer to Question 1b(ii): It is required that g'(p) = 0 for an order of convergence that is at least quadratic. For the p calculated in part a, g'(p) =/= 0 and therefore cnanot have any order of convergence that isn't linear.
        
    """
    pass

def q1C_answer():
    """
    Answer to Question 1c(i): No

    Answer to Question 1c(ii): Since p -> 0, then |g'(p)| = 0, but 0 < k < 1. Hence Theorem 1.6 is not invoked since we require 0 < k < 1 to exist such that |g(p)|<=k
        
    """
    pass

#bisection_simple method taken from listing 1.2 of the lecture notes
def bisection_simple(f,a,b,Nmax):
    """
    Bisection Method: Returns a numpy array of the 
    sequence of approximations obtained by the bisection method.
    
    Inputs:
    ----------
    f : function
        Input function for which the zero is to be found.
    a : float
        Left side of interval.
    b : float
        Right side of interval.
    Nmax : integer
        Number of iterations to be performed.

    Returns
    -------
    p_array : numpy.ndarray, 
            Array containing the sequence of approximations. 
            The shape is (Nmax,)
    """
    
    #Initialise numpy array of size Nmax
    p_array=np.zeros(Nmax,)
    
    #Begin bisection method:
    fa=f(a)
    for n in range(Nmax):
        p=(a+b)/2  # midpoint
        fp=f(p)    # evaluate f at midpoint
        #define new interval
        if fp*fa>0:
            a=p
            fa=fp
        else:
            b=p
        p_array[n]=p
    return p_array

def newton_with_stopping(f,df, p0,Nmax,TOL,p=None):
    """
    Implementation of the Newton method for fixed points and root finding

    ----------

    Inputs: 
        f (lambda function or 'def' function): The function 'f' for which we aim to find the root of.
        df (lambda function or 'def' function): The derivative of the function 'f'
        p0 (float): The initial guess of the root of 'f' to start the Newton method
        Nmax (integer): The maximum number of iterations of the Newton method
        TOL (float): Tolerance for the stopping criteria |f(p_m)| <= TOL
        p (float): The exact root. Defaults to None

    ----------

    Returns:
        p_array (numpy.ndarray): The iterations of p_n generated by Newton's method
        fig (matplotlib.subplot): The canvas of the graph of the absolute error |p-p_n| - only if p is provided
        ax (matplotlib.subplot): The axis object of the graph of the absolute error |p-p_n| - only if p is provided

    ----------
    """
   
    
    p_array=np.zeros(Nmax,)
    
    #Write your code for Newton's method according to the instructions:

    n = 0
    while n < Nmax:
        p_n = p0 - (f(p0) / df(p0))
        p_array[n] = p_n
        if(np.abs(f(p_n)) <= TOL):
            break
        n += 1
        p0 = p_n
    p_array = p_array[:n+1]

    
    fig = ax = None

    # Write your code to generate plot according to the instructions:

    if(p is not None):
        fig, ax = plt.subplots()
        errors = np.abs(p - np.array(p_array))

        ax.set_yscale("log")
        ax.set_xlabel("'nth' iteration")
        ax.set_ylabel("|p-p_n|")

        ax.plot(np.arange(len(errors)), errors, label="|p-p_n|")

        ax.legend()


    if fig is not None and ax is not None:
        return p_array, fig, ax
    else:
        return p_array


def q2B_answer():
    """
    Answer to Question 2b(i): Yes

    Answer to Question 2b(ii): At p=1, f(1) = 0 and f'(1) = 0. Corollary 1.2 requires that f'(p) is not equal to 0 for quadratic convergence, so the corollary doesn't apply here.
    """
    pass

def secant_with_stopping(f, p0, p1, Nmax, TOL):
    """
    Implements the secant method to find a root of the function 'f'

    ----------
    Inputs:
        f (lambda or 'def' function): The function for which we aim to find the root
        p0 (float): a real number representing the initial guess for the root of 'f'
        p1 (float): a real number representing the first guess for the root of 'f'
        Nmax (integer): The maximum number of iterations of the secant method
        TOL (float): Tolerance for the stopping criteria |p_m - p_(m-1)| <= TOL(1 + |p_m|)

    ----------
    Returns:
        p_array (numpy.ndarray): Containing the iterations of p_n generated by the secant method

    """

    p_array=np.zeros(Nmax,)
    
    #Write your code for Secants's method according to the instructions:

    p_array[0] = p1

    n = 1
    q0 = f(p0)
    q1 = f(p1)
    while n < Nmax:
        denom_correction = 1e-15 if np.abs(q1 - q0) < 1e-15 else q1 - q0

        p = p1 - (q1 * ((p1-p0)/(denom_correction)))
        if(np.abs(p - p_array[n-1]) <= TOL*(1 + np.abs(p))):
            break
        p_array[n] = p
        n += 1
        p0 = p1
        q0 = q1
        p1 = p
        q1 = f(p)
    
    return p_array[:n]



def plot_convergence(p, f, df,  p0_newton, p0_sec, p1_sec,Nmax, TOL):
    """
    Currently this function plots the error |p-p_n| obtained via Newton's and
    Secant methods encoded in the functions above (once completed). 
    You must modify this modify this function to include bisection method 
    following the instructions. 
    
    
    Inputs:
    ----------
    p: float
        Eact root    
    f : function
        Input function for which the zero is to be found.
    df : function
        Derivative of the input function for which the zero is to be found.
    p0_newton : float
        initial approximation for Newton's method'
    p0_sec : float
        initial approximation for secant method
    p1_sec : float
        initial approximation for secant method
    Nmax : integer
        Number of iterations to be performed.
    TOL : float
        Tolerance for stopping criteria

    Output:
    -------
    fig, ax: matplotlib.pyplot objects of the figure that is produced
    

    """
    methods = ["newton", "secant", "bisection"]

    # map method name -> function that returns the iterate list/array
    runners = {
        "newton": newton_with_stopping(f, df, p0_newton, Nmax, TOL),
        "secant": secant_with_stopping(f, p0_sec, p1_sec, Nmax, TOL),
        "bisection": bisection_simple(f, min(p0_sec,p1_sec), max(p0_sec, p1_sec),Nmax)
    }
    #define plotting style
    styles = {
        "newton": dict(marker="*", linestyle="--", color="blue",  label="Newton"),
        "secant": dict(marker="o", linestyle="-",  color="black", label="Secant"),
        "bisection": dict(marker="*", linestyle="-", color="green", label="Bisection")
    }



    fig, ax = plt.subplots()
    ax.set_yscale("log")
    ax.set_xlabel("iteration ($n$)", fontsize=16)
    ax.set_ylabel(r"$|p - p_{n}|$", fontsize=16)
    ax.grid(True)
    
    #loop over methods and plot errors
    
    for m in methods:
        iters =runners[m]
        n = np.arange(1, len(iters) + 1)
        ax.plot(n, np.abs(iters - p), **styles[m])

    ax.legend(fontsize=16, loc="best")
    
    return fig, ax
    

def q4B_answer():
    """
    Answer to Question 4b(i): Yes. f is continuous over the interval [-2,-1] and f(a)f(b) = -6 < 0. By theorem 1.1, we are guaranteed to have convergence
        
    
    Answer to Question 4b(ii): No. Newton's method is only guaranteed to converge if p0 lies in the interval [p-delta, p+delta] for some delta > 0. 
        
    
    Answer to Question 4b(iii): Yes, Newton's method and the secant method fails to converge because |p-p_n| does not decrease towards 0, and instead oscillates above 0
    
    """
    pass


def scaled_pivoting(A, b ,m):
    """
    
    
    
    """
    
    #Write your code for scaled partial pivoting according to the instructions:

    tildeA = np.hstack((A,b))
    n = np.shape(tildeA)[0]
    s_i = np.zeros(n)

    #determine if a solution exists (terminates if any entry of the ith-jth entry is 0)
    for i in range(0, n):
        si_element = np.max(np.abs(tildeA[i, :n]))
        if si_element == 0:
            raise ValueError("This system does not have a unique solution")
        s_i[i] = si_element
    

    for i in range(0, n-1):
        ratios = np.max(np.abs(tildeA[i:n, i]) / s_i[i:n])
        print(tildeA[i:n, i])
        print(s_i[i:n])
        p = i + np.argmax(ratios)


    



    return tildeA, perm

def sp_solve(A,b):
    """
    
    
    """
    
    #Write your code to solve the system according to the instructions:
    
    return x

            


def q5C_answer():
    """
    Answer to Question 5ci:
    
    Answer to Question 5cii: 
        
    """
    pass
