"""
Main Python script for submission
Implements the required functions for CW1.
"""
import numpy as np
import matplotlib.pyplot as plt

def show_answer(func, word_limit=40):
    """
    Do not remove or modify this function
    """
    
    text = func.__doc__ or ""
    words = text.split()

    limited = words[:word_limit]
    truncated = len(words) > word_limit

    result = " ".join(limited)
    if truncated:
        result += " ...[truncated]"

    return result


def fixedpoint_with_stopping(g, p0, Nmax, TOL, p=None, C=None, k=None):
    """
    
    Using the fixed-point iteration method, this function solves the problem p = g(p)

    Args:
        :param g: The function which will be iterated over
        :param p0: The initial guess to the solution of p = g(p)
        :param Nmax: The maximum number of iterations over g
        :param TOL: The tolerance for the stopping criteria defined as |p_m - p_(m-1)| <= TOL
        :param p: The exact solution to p = g(p) if known, otherwise it is None
        :param C: One of the positive constants used to define the stopping criteria |p - p_n| <= CK^n 
        :param K: One of the positive constants used to define the stopping criteria |p - p_n| <= CK^n

    Returns:
        :numpy.ndarray called p_array with shape (m,) containing the iterates p_n generated by the fixed point iteration before
        reaching Nmax iterations or after the iterations hits Nmax

    Outputs:
        :(if p is known) a graph corresponding to the plot of the absolute error |p - p_n| using a logarithmic scale on the y-axis
        :(if C and k are provided) a plot of the error bound CK^n on the same graph as the above 
    
    """


    p_array = np.zeros(Nmax)
    
    #Write your code for fixed point iteration according to the instructions:

    p0 = g(p0)
    p_array[0] = p0

    n = 1
    while n < Nmax:
        p_n = g(p0)
        p_array[n] = p_n
        if(np.abs(p_n - p_array[n-1]) <= TOL):
            break
        p0 = p_n
        n += 1
    p_array = p_array[:n+1]

    # Write your code to generate plots according to the instructions:

    if p is not None:
        fig, ax = plt.subplots()
        errors = np.abs(p - np.array(p_array))
        n = np.arange(len(errors))

        ax.set_yscale("log")
        ax.set_xlabel("Iteration")
        ax.set_ylabel("|p - p_n|")

        ax.plot(n, errors, label="|p - p_n|")

        if C is not None and k is not None:
            bound = C * (k ** n)
            ax.plot(n, bound, "--", label="Ck^n")
        ax.legend()
    else:
        fig = ax = None

    if fig is not None and ax is not None:
        return p_array, fig, ax
    else:
        return p_array

def q1B_answer():
    """
    Answer to Question 1b(i): 
    
    Answer to Question 1b(ii): 
        
    """
    pass

def q1C_answer():
    """
    Answer to Question 1c(i):

    Answer to Question 1c(ii): 
        
    """
    pass

def newton_with_stopping(f,df, p0,Nmax,TOL,p=None):
    """
    Add your docstrings here    
          
    """
   
    
    p_array=np.zeros(Nmax,)
    
    #Write your code for Newton's method according to the instructions:

    
    fig = ax = None

    # Write your code to generate plot according to the instructions:



    if fig is not None and ax is not None:
        return p_array, fig, ax
    else:
        return p_array


def q2B_answer():
    """
    Answer to Question 2b(i):

    Answer to Question 2b(ii):
    """
    pass

def secant_with_stopping(f, p0, p1, Nmax, TOL):
    """
    Add your docstrings here    

    """

    p_array=np.zeros(Nmax,)
    
    #Write your code for Secants's method according to the instructions:

    
    return p_array








def plot_convergence(p, f, df,  p0_newton, p0_sec, p1_sec,Nmax, TOL):
    """
    Currently this function plots the error |p-p_n| obtained via Newton's and
    Secant methods encoded in the functions above (once completed). 
    You must modify this modify this function to include bisection method 
    following the instructions. 
    
    
    Inputs:
    ----------
    p: float
        Eact root    
    f : function
        Input function for which the zero is to be found.
    df : function
        Derivative of the input function for which the zero is to be found.
    p0_newton : float
        initial approximation for Newton's method'
    p0_sec : float
        initial approximation for secant method
    p1_sec : float
        initial approximation for secant method
    Nmax : integer
        Number of iterations to be performed.
    TOL : float
        Tolerance for stopping criteria

    Output:
    -------
    fig, ax: matplotlib.pyplot objects of the figure that is produced
    

    """
    methods = ["newton", "secant"]

    # map method name -> function that returns the iterate list/array
    runners = {
        "newton": newton_with_stopping(f, df, p0_newton, Nmax, TOL),
        "secant": secant_with_stopping(f, p0_sec, p1_sec, Nmax, TOL),
    }
    #define plotting style
    styles = {
        "newton": dict(marker="*", linestyle="--", color="blue",  label="Newton"),
        "secant": dict(marker="o", linestyle="-",  color="black", label="Secant"),
    }



    fig, ax = plt.subplots()
    ax.set_yscale("log")
    ax.set_xlabel("iteration ($n$)", fontsize=16)
    ax.set_ylabel(r"$|p - p_{n}|$", fontsize=16)
    ax.grid(True)
    
    #loop over methods and plot errors
    
    for m in methods:
        iters =runners[m]
        n = np.arange(1, len(iters) + 1)
        ax.plot(n, np.abs(iters - p), **styles[m])

    ax.legend(fontsize=16, loc="best")
    
    return fig, ax
    

def q4B_answer():
    """
    Answer to Question 4b(i): 
        
    
    Answer to Question 4b(ii): 
        
    
    Answer to Question 4b(iii): 
    
    """
    pass


def scaled_pivoting(A, b ,m):
    """
    Add your docstrings here    
    
    
    """
    
    #Write your code for scaled partial pivoting according to the instructions:

    return tildeA, perm

def sp_solve(A,b):
    """
    
    
    """
    
    #Write your code to solve the system according to the instructions:
    
    return x

            


def q5C_answer():
    """
    Answer to Question 5ci:
    
    Answer to Question 5cii: 
        
    """
    pass
