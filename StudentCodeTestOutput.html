<!DOCTYPE html>
<html><head> 
Output from Code tests</head> 
<body> 
<p> <b>Case: Q1a Case I</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
doc_string = cw.fixedpoint_with_stopping.__doc__<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test 1-I: doc</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">doc_string = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">
    
    Using the fixed-point iteration method, this function solves the problem p = g(p)

    Inputs:
    ----------

    g: Callable[[float],float]
        The function which will be iterated over
    p0: float
        The initial guess to the solution of p = g(p)
    Nmax: integer
        The maximum number of iterations over g
    TOL: float
        The tolerance for the stopping criteria defined as |p_m - p_(m-1)| &lt;= TOL
    p: float
        The exact solution to p = g(p) if known, otherwise it is None
    C: float
        One of the positive constants used to define the stopping criteria |p - p_n| &lt;= CK^n 
    k: float
        One of the positive constants used to define the stopping criteria |p - p_n| &lt;= CK^n

    Output:
    ----------
    p_array: np.ndarray
        Containing the iterates p_n generated by the fixed point iteration before or after reaching Nmax iterations
    fig,ax: matplotlib.pyplot objects of the graph of the absolute errors of |p-p_n| if p is provided. 
            Also outputs the plot of the error bound Ck^n if C and k are provided
            Defaults to None if none of p, C or k are provided
    
    </pre>
<p> <b>Case: Q1a Case II</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
g = lambda x:  1/3*(x**2 -1)<br>
p0 = 1.0<br>
Nmax = 10<br>
TOL = 1e-11<br>
p_array = cw.fixedpoint_with_stopping(g,p0,Nmax,TOL)<br>
p_array_type = type(p_array)<br>
p_array_shape = np.shape(p_array)<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test 1-II-1: p_array_type</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array_type = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">&lt;class 'numpy.ndarray'&gt;</pre>
<pre><p style="margin-left:30px;"><u>Test 1-II-2: p_array_shape</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array_shape = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">(10,)</pre>
<pre><p style="margin-left:30px;"><u>Test 1-II-3: p_array</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">[ 0.         -0.33333333 -0.2962963  -0.3040695  -0.30251391 -0.30282844
 -0.30276498 -0.30277779 -0.3027752  -0.30277573]</pre>
<p> <b>Case: Q1a Case III</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
g = lambda x:  1/3*(x**2 -1)<br>
p0 = 1.0<br>
Nmax = 50<br>
TOL = 1e-11<br>
p_array = cw.fixedpoint_with_stopping(g,p0,Nmax,TOL)<br>
p_array_type = type(p_array)<br>
p_array_shape = np.shape(p_array)<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test 1-III-1: p_array_type</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array_type = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">&lt;class 'numpy.ndarray'&gt;</pre>
<pre><p style="margin-left:30px;"><u>Test 1-III-2: p_array_shape</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array_shape = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">(17,)</pre>
<pre><p style="margin-left:30px;"><u>Test 1-III-3: p_array</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">[ 0.         -0.33333333 -0.2962963  -0.3040695  -0.30251391 -0.30282844
 -0.30276498 -0.30277779 -0.3027752  -0.30277573 -0.30277562 -0.30277564
 -0.30277564 -0.30277564 -0.30277564 -0.30277564 -0.30277564]</pre>
<p> <b>Case: Q1a Case IV</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
g = lambda x:  1/3*(x**2 -1)<br>
p0 = 1.0<br>
Nmax = 10<br>
TOL = 1e-11<br>
p=(3-np.sqrt(13))/2<br>
_,fig,ax = cw.fixedpoint_with_stopping(g,p0,Nmax,TOL,p)<br>
figI = fig<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test1-IV: Plot</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">figI = </p></pre><p style="margin-left:90px;"><img src="figI.png" height="400" width="600"></p><br><br>
<p> <b>Case: Q1a Case V</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
g = lambda x:  1/3*(x**2 -1)<br>
p0 = 1.0<br>
Nmax = 10<br>
TOL = 1e-11<br>
p=(3-np.sqrt(13))/2<br>
C=2<br>
k=2/3<br>
_,fig,ax = cw.fixedpoint_with_stopping(g,p0,Nmax,TOL,p,C,k)<br>
figII = fig<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test1-V: Plot</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">figII = </p></pre><p style="margin-left:90px;"><img src="figII.png" height="400" width="600"></p><br><br>
<p> <b>Case: Q1b</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
answer = cw.show_answer(cw.q1B_answer, 60)<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test1-VI: Plot</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">answer = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">Answer to Question 1b(i): Linear Answer to Question 1b(ii): It is required that g'(p) = 0 for an order of convergence that is at least quadratic. For the p calculated in part a, g'(p) =/= 0 and therefore cnanot have any order of convergence that isn't linear.</pre>
<p> <b>Case: Q1c</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
answer = cw.show_answer(cw.q1C_answer, 60)<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test1-VII: Plot</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">answer = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">Answer to Question 1c(i): No Answer to Question 1c(ii): Since p -&gt; 0, then |g'(p)| = 0, but 0 &lt; k &lt; 1. Hence Theorem 1.6 is not invoked since we require 0 &lt; k &lt; 1 to exist such that |g(p)|&lt;=k</pre>
<p> <b>Case: Q2a Case I</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
f = lambda x: np.cos(x) - x<br>
df = lambda x: -np.sin(x) - 1<br>
p0 = 0.0<br>
Nmax = 3<br>
TOL = 1e-16<br>
p_array = cw.newton_with_stopping(f,df,p0,Nmax,TOL)<br>
p_array_type = type(p_array)<br>
p_array_shape = np.shape(p_array)<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test 2-I-1: p_array_type</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array_type = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">&lt;class 'numpy.ndarray'&gt;</pre>
<pre><p style="margin-left:30px;"><u>Test 2-I-2: p_array_shape</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array_shape = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">(3,)</pre>
<pre><p style="margin-left:30px;"><u>Test 2-I-3: p_array</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">[1.         0.75036387 0.73911289]</pre>
<p> <b>Case: Q2a Case II</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
f = lambda x: np.cos(x) - x<br>
df = lambda x: -np.sin(x) - 1<br>
p0 = 0.0<br>
Nmax = 10<br>
TOL = 1e-16<br>
p_array = cw.newton_with_stopping(f,df,p0,Nmax,TOL)<br>
p_array_type = type(p_array)<br>
p_array_shape = np.shape(p_array)<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test 2-II-1: p_array_type</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array_type = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">&lt;class 'numpy.ndarray'&gt;</pre>
<pre><p style="margin-left:30px;"><u>Test 2-II-2: p_array_shape</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array_shape = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">(5,)</pre>
<pre><p style="margin-left:30px;"><u>Test 2-II-3: p_array</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">[1.         0.75036387 0.73911289 0.73908513 0.73908513]</pre>
<p> <b>Case: Q2a Case III</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
f = lambda x: np.cos(x) - x<br>
df = lambda x: -np.sin(x) - 1<br>
p0 = 0.0<br>
Nmax = 20<br>
TOL = 1e-16<br>
p = np.float64(0.73908513321516064165531207047)<br>
_,fig,ax = cw.newton_with_stopping(f,df,p0,Nmax,TOL,p)<br>
figIII = fig<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test2-III: Plot</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">figIII = </p></pre><p style="margin-left:90px;"><img src="figIII.png" height="400" width="600"></p><br><br>
<p> <b>Case: Q2b</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
answer = cw.show_answer(cw.q2B_answer, 60)<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test2-IV: Plot</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">answer = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">Answer to Question 2b(i): Yes Answer to Question 2b(ii): At p=1, f(1) = 0 and f'(1) = 0. Corollary 1.2 requires that f'(p) is not equal to 0 for quadratic convergence, so the corollary doesn't apply here.</pre>
<p> <b>Case: Q3 Case I</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
f = lambda x: x**2 - 2<br>
p0 = 1.0<br>
p1 = 2.0<br>
Nmax = 12<br>
TOL = 10**(-6)<br>
p_array = cw.secant_with_stopping(f,p0,p1,Nmax,TOL)<br>
p_array_shape = np.shape(p_array)<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test 3-I-1: p_array_shape</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array_shape = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">(6,)</pre>
<pre><p style="margin-left:30px;"><u>Test 3-I-2: p_array</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">[2.         1.33333333 1.4        1.41463415 1.41421144 1.41421356]</pre>
<p> <b>Case: Q3 Case II</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
f = lambda x: x**2 - 2<br>
p0 = 1.0<br>
p1 = 2.0<br>
Nmax = 12<br>
TOL = 10**(-16)<br>
p_array = cw.secant_with_stopping(f,p0,p1,Nmax,TOL)<br>
p_array_shape = np.shape(p_array)<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test 3-II-1: p_array_shape</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array_shape = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">(8,)</pre>
<pre><p style="margin-left:30px;"><u>Test 3-II-2: p_array</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">p_array = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">[2.         1.33333333 1.4        1.41463415 1.41421144 1.41421356
 1.41421356 1.41421356]</pre>
<p> <b>Case: Q4a Case I</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
f = lambda x: x - np.cos(x)<br>
df = lambda x: 1 + np.sin(x)<br>
p0_newton = 0.0<br>
p0_sec = 0.0<br>
p1_sec=2.0<br>
Nmax = 20<br>
pe = np.float64(0.73908513321516064165531207047)<br>
TOL = 1e-16<br>
fig,ax = cw.plot_convergence(pe,f,df,p0_newton,p0_sec,p1_sec,Nmax,TOL)<br>
fig4I = fig<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test4-I: Plot</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">fig4I = </p></pre><p style="margin-left:90px;"><img src="fig4I.png" height="400" width="600"></p><br><br>
<p> <b>Case: Q4b</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
answer = cw.show_answer(cw.q4B_answer, 80)<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test4-2: Plot</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">answer = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">Answer to Question 4b(i): Yes. f is continuous over the interval [-2,-1] and f(a)f(b) = -6 &lt; 0. By theorem 1.1, we are guaranteed to have convergence Answer to Question 4b(ii): No. Newton's method is only guaranteed to converge if p0 lies in the interval [p-delta, p+delta] for some delta &gt; 0. Answer to Question 4b(iii): Yes, Newton's method and the secant method fails to converge because |p-p_n| does not decrease towards 0, and instead oscillates above 0</pre>
<p> <b>Case: Q5a Case I</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
doc_string = cw.scaled_pivoting.__doc__<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test 5-I: doc</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">doc_string = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">
    Implements Gaussian elimination with scaled partial pivoting to solve the system of equations Ax=b

    Inputs:
    ---------
    A: numpy.ndarray
        Represents the square matrix 'A' with shape (n,n)
    b: numpy.ndarray
        Represents the column vector 'b' with shape (n,1)
    m: integer
        Used to prematurely stop the Gaussian elimination where 1&lt;= m &lt;= n-1
    
    Outputs:
    ----------
    tildeA: numpy.ndarray
        Augmented matrix arrived at by starting with tildeA = [A | b] and performing Gaussian elimination with scaled partial pivoting.
    perm: numpy.ndarray
        Permutation vector that records the row ordering of the original augmented matrix [A | b]
    
    </pre>
<p> <b>Case: Q5a Case II</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
A = np.array([[1,-5,1],[10,0.0,20],[5,10,-1]], dtype=float)<br>
b = np.array([[7],[6],[4]], dtype=float)<br>
n=3<br>
m1=1<br>
m2=2<br>
M1,perm1 = cw.scaled_pivoting(A,b,m1)<br>
M1 = M1<br>
perm1 = perm1<br>
M2,perm2 = cw.scaled_pivoting(A,b,m2)<br>
M2 = M2<br>
perm2 = perm2<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test 5-II-1</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">M1 = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">[[ 10.    0.   20.    6. ]
 [  0.   -5.   -1.    6.4]
 [  0.   10.  -11.    1. ]]</pre>
<pre><p style="margin-left:30px;"><u>Test 5-II-2</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">M2 = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">[[ 10.    0.   20.    6. ]
 [  0.   -5.   -1.    6.4]
 [  0.    0.  -13.   13.8]]</pre>
<pre><p style="margin-left:30px;"><u>Test 5-II-3</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">perm1 = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">[1 0 2]</pre>
<pre><p style="margin-left:30px;"><u>Test 5-II-4</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">perm2 = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">[1 0 2]</pre>
<p> <b>Case: Q5b Case I</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
A = np.array([[1,-5,1],[10,0.0,20],[5,10,-1]], dtype=float)<br>
b = np.array([[7],[6],[4]], dtype=float)<br>
x = cw.sp_solve(A,b)<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test 5-III-1</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">x = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">[[ 2.72307692]
 [-1.06769231]
 [-1.06153846]]</pre>
<p> <b>Case: Q5c</b><br></p>
<p style="margin-left:30px;"> <u>Commands Run:</u> </p>
<p style="margin-left:60px;"<tt><tt>import CW1_solvers as cw<br>
answer = cw.show_answer(cw.q5C_answer, 60)<br>
</tt></tt></p><pre><p style="margin-left:30px;"><u>Test5-IV: Plot</u><br></p></pre>
<p style="margin-left:60px;"> Student Output: </p>
<pre><p style="margin-left:60px;">answer = </p></pre><pre style="margin-left:90px; white-space:pre-wrap;">Answer to Question 5ci: x = [-1,1,1] Answer to Question 5cii: We observe catastrophic cancellation between 1 and 1+epsilon; since we lose precision for epsilon this small, the difference is indistinguishable from 0. This is an issue when dividing by the pivot which is essentially the same as dividing by 0.</pre>
</body> 
</html> 
